{"componentChunkName":"component---src-templates-blog-post-js","path":"/bluez-pairing-python-agent-workaround-authentication-failed/","result":{"data":{"site":{"siteMetadata":{"title":"Boris's Blog"}},"markdownRemark":{"id":"fa5ee807-c206-563f-ade2-c7ce58e4344f","excerpt":"As developers, we often embark on projects with a clear plan, only to hit unexpected roadblocks thrown up by the intricacies of the systems we interact with…","html":"<p>As developers, we often embark on projects with a clear plan, only to hit unexpected roadblocks thrown up by the intricacies of the systems we interact with. Recently, while working on the D2Explorer project – a tool to pair with a specific Bluetooth LE device (the Huawei Watch D2) on Linux – we encountered a particularly stubborn issue involving BlueZ, the Linux Bluetooth stack. This post details our journey through debugging a persistent <code class=\"language-text\">AuthenticationFailed</code> error and the workarounds we ultimately implemented.</p>\n<h2>The Initial Plan: An Internal C++ Pairing Agent</h2>\n<p>Our goal was to create a self-contained C++ application capable of handling the entire pairing process. This naturally included implementing a BlueZ Pairing Agent directly within our application using the <code class=\"language-text\">sd-bus</code> library, which provides C/C++ bindings for D-Bus.</p>\n<p>The plan seemed straightforward:</p>\n<ol>\n<li>Connect to the system D-Bus.</li>\n<li>Find the Bluetooth adapter (<code class=\"language-text\">org.bluez.Adapter1</code>).</li>\n<li>Implement a C++ class exposing the <code class=\"language-text\">org.bluez.Agent1</code> interface.</li>\n<li>Register this agent with BlueZ's <code class=\"language-text\">org.bluez.AgentManager1</code> using <code class=\"language-text\">RegisterAgent</code> and <code class=\"language-text\">RequestDefaultAgent</code>. We initially targeted the <code class=\"language-text\">DisplayYesNo</code> capability, later simplifying to <code class=\"language-text\">NoInputNoOutput</code>.</li>\n<li>Discover the target device (<code class=\"language-text\">org.bluez.Device1</code>).</li>\n<li>Call the <code class=\"language-text\">Pair()</code> method on the device's D-Bus interface.</li>\n<li>Our internal agent would automatically handle any callbacks from BlueZ (like <code class=\"language-text\">RequestConfirmation</code> or <code class=\"language-text\">RequestAuthorization</code>) to allow pairing without user interaction.</li>\n<li>Proceed with trusting the device and establishing a GATT connection.</li>\n</ol>\n<p>This approach, using <code class=\"language-text\">sd-bus</code> for both method calls and agent implementation, aimed for a clean, integrated solution.</p>\n<h2>The Roadblock: <code class=\"language-text\">org.bluez.Error.AuthenticationFailed</code></h2>\n<p>Everything seemed to work up until step 6. We could find the adapter, register our agent ( seemingly successfully, according to D-Bus), discover the device, but the moment we called the <code class=\"language-text\">Device1.Pair()</code> method via <code class=\"language-text\">sd_bus_call_method</code>, BlueZ would almost immediately return an error: <code class=\"language-text\">org.bluez.Error.AuthenticationFailed</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[BluetoothDevice] Calling Device1.Pair() method via D-Bus\n[BluetoothDevice] Device1.Pair() method threw exception: Failed to call method 'Pair': Input/output error - D-Bus error: org.bluez.Error.AuthenticationFailed (Authentication Failed)</code></pre></div>\n<p>This was perplexing. Our agent <em>was</em> registered. We tried different agent capabilities (<code class=\"language-text\">DisplayYesNo</code>, <code class=\"language-text\">NoInputNoOutput</code>). We meticulously checked the <code class=\"language-text\">sd-bus</code> vtable setup and the agent method implementations, ensuring they returned success promptly as required for automated pairing. We used <code class=\"language-text\">busctl</code> and <code class=\"language-text\">gdbus</code> to monitor D-Bus traffic, confirming our agent registration calls seemed correct, yet the <code class=\"language-text\">Pair()</code> call consistently failed with <code class=\"language-text\">AuthenticationFailed</code>.</p>\n<p>Further investigation and searching online revealed potential complexities and changes in how newer BlueZ versions (specifically reports around 5.66, 5.72 and later) handle agent interactions and pairing initiation, though concrete documentation on exact internal changes was scarce <small><a href=\"#ref1\">[1]</a></small>, <small><a href=\"#ref2\">[2]</a></small>.</p>\n<h2>The Breakthrough: Testing with an External Python Agent</h2>\n<p>To isolate the problem, we decided to take our internal C++ agent out of the equation temporarily. We used a standard BlueZ example Python script, <code class=\"language-text\">simple-agent.py</code> (or a slightly modified version), run as a separate process, to register an agent with <code class=\"language-text\">NoInputNoOutput</code> capability <em>before</em> running our C++ application (which now <em>only</em> performed discovery and method calls, without registering its own agent).</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># Terminal 1: Run the external agent</span>\n<span class=\"token function\">sudo</span> python simple-agent.py NoInputNoOutput\n\n<span class=\"token comment\"># Terminal 2: Run our C++ app (modified to *not* register its own agent)</span>\n<span class=\"token function\">sudo</span> ./build/huawei_pair_app <span class=\"token operator\">&lt;</span>MAC<span class=\"token operator\">></span> <span class=\"token operator\">&lt;</span>QR_VALUE<span class=\"token operator\">></span></code></pre></div>\n<p>The result was immediate and illuminating:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[BluetoothDevice] Calling Device1.Pair() method via D-Bus\n[BluetoothDevice] Device1.Pair() method succeeded  &lt;--- SUCCESS!</code></pre></div>\n<p>The <code class=\"language-text\">Device1.Pair()</code> call now succeeded consistently! The <code class=\"language-text\">AuthenticationFailed</code> error vanished completely when using the external Python agent. This strongly indicated that the issue wasn't with the <code class=\"language-text\">Pair()</code> call itself, nor with the fundamental pairing capability of the device or BlueZ, but specifically with how our C++ application, using <code class=\"language-text\">sd-bus</code>, was registering and interacting as a pairing agent with these newer BlueZ versions.</p>\n<h2>Why Did the Internal C++ Agent Fail? (Hypotheses)</h2>\n<p>While we don't have a definitive root cause from BlueZ internals, several hypotheses emerged:</p>\n<ol>\n<li><strong>Timing Issues:</strong> Perhaps the <code class=\"language-text\">sd-bus</code> registration or method handling within our single-threaded (or multi-threaded) C++ event loop wasn't responding in the exact timing window expected by <code class=\"language-text\">bluetoothd</code>.</li>\n<li><strong><code class=\"language-text\">sd-bus</code> vs. <code class=\"language-text\">python-dbus</code> Subtleties:</strong> There might be subtle differences in how <code class=\"language-text\">sd-bus</code> interacts with the D-Bus daemon or how it handles object lifetimes compared to the <code class=\"language-text\">python-dbus</code> library used by the example agent.</li>\n<li><strong>BlueZ Internal Changes:</strong> BlueZ 5.72+ might have introduced stricter requirements or changed internal sequences for agent interaction that <code class=\"language-text\">sd-bus</code>, when used programmatically within the same application initiating the pairing, doesn't satisfy perfectly.</li>\n<li><strong>Potential <code class=\"language-text\">sd-bus</code> Bug/Limitation:</strong> While less likely for such a core library, a specific bug related to registering object vtables and handling method calls in this context couldn't be entirely ruled out.</li>\n</ol>\n<h2>The Next Workaround: D-Bus Property Polling</h2>\n<p>Overcoming the <code class=\"language-text\">AuthenticationFailed</code> error was a major step, but it wasn't the end of the story. While the <code class=\"language-text\">Pair()</code> call now worked with the external agent, we found that relying on D-Bus <code class=\"language-text\">PropertiesChanged</code> signals (via <code class=\"language-text\">sd-bus</code>) to know when the <code class=\"language-text\">Paired</code>, <code class=\"language-text\">Trusted</code>, <code class=\"language-text\">Connected</code>, and <code class=\"language-text\">ServicesResolved</code> properties actually became <code class=\"language-text\">true</code> was unreliable. Sometimes the signals arrived late, sometimes seemingly not at all.</p>\n<p>To create a robust process, we had to implement another layer of workarounds: <strong>active polling</strong>.</p>\n<p>In our main C++ application loop, we added logic to:</p>\n<ol>\n<li>Check the current state of our <code class=\"language-text\">ConnectionManager</code>.</li>\n<li>If in the <code class=\"language-text\">Pairing</code> state, periodically call <code class=\"language-text\">BluetoothDevice::isPaired()</code>.</li>\n<li>If in the <code class=\"language-text\">Trusting</code> state, periodically call <code class=\"language-text\">BluetoothDevice::isTrusted()</code>.</li>\n<li>If in the <code class=\"language-text\">ConnectingGatt</code> state, periodically call <code class=\"language-text\">BluetoothDevice::isConnected()</code> and then <code class=\"language-text\">BluetoothDevice::areServicesResolved()</code>.</li>\n</ol>\n<p>Crucially, the <code class=\"language-text\">isPaired()</code>, <code class=\"language-text\">isTrusted()</code>, <code class=\"language-text\">isConnected()</code>, and <code class=\"language-text\">areServicesResolved()</code> methods were modified. They now first check a locally cached atomic boolean (updated by the D-Bus signal handler, if it works), but if the cached value is <code class=\"language-text\">false</code>, they <strong>actively query the current property value directly from BlueZ via a D-Bus <code class=\"language-text\">Get</code> property call</strong>.</p>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">// Simplified example for isPaired()\nbool BluetoothDevice::isPaired() {\n    bool cachedValue = mockPaired_.load(); // Check signal-updated cache\n    if (cachedValue) return true;\n\n    // If cache is false, poll D-Bus directly\n    Logger::debug(&quot;[Polling] Polling Paired property via D-Bus...&quot;);\n    bool polledValue = false;\n    adapter_.getObjectProperty&lt;bool&gt;(devicePath_, &quot;org.bluez.Device1&quot;, &quot;Paired&quot;, polledValue); // Active D-Bus call\n    if (polledValue) mockPaired_.store(true); // Update cache\n    return polledValue;\n}</code></pre></div>\n<p>This polling mechanism, while less elegant than pure signal-driven logic, proved necessary to reliably detect state changes when D-Bus signals were inconsistent. We also added similar polling for the GATT service/characteristic discovery phase.</p>\n<h2>Code Implications</h2>\n<p>This journey led to several architectural changes:</p>\n<ol>\n<li><strong>External Dependency:</strong> Our application now requires a separate pairing agent process (like the Python script) to be running.</li>\n<li><strong>Increased Complexity:</strong> The C++ application needed additional polling logic in its main loop to handle state transitions reliably, adding complexity beyond the intended signal-driven approach.</li>\n<li><strong>Less Self-Contained:</strong> The goal of a single, self-contained executable was compromised.</li>\n</ol>\n<h2>Conclusion</h2>\n<p>Interfacing with complex system daemons like BlueZ via D-Bus can present unexpected challenges, especially across different versions. Our experience showed that while <code class=\"language-text\">sd-bus</code> is powerful, its interaction with BlueZ 5.72+ for <em>internal</em> agent registration during pairing initiation was problematic, leading to <code class=\"language-text\">AuthenticationFailed</code> errors.</p>\n<p>Switching to a standard <em>external</em> Python agent resolved the immediate <code class=\"language-text\">Pair()</code> failure, highlighting that the issue lay in the agent interaction mechanism from our C++ app. Furthermore, the unreliability of <code class=\"language-text\">PropertiesChanged</code> signals necessitated implementing active D-Bus property polling for <code class=\"language-text\">Paired</code>, <code class=\"language-text\">Trusted</code>, <code class=\"language-text\">Connected</code>, and <code class=\"language-text\">ServicesResolved</code> states, as well as for GATT object discovery.</p>\n<p>If you're facing similar <code class=\"language-text\">AuthenticationFailed</code> errors during automated Bluetooth pairing on Linux with recent BlueZ versions, consider:</p>\n<ol>\n<li>Testing with a standard external agent (like BlueZ's <code class=\"language-text\">simple-agent.py</code>) <small><a href=\"#ref3\">[3]</a></small>.</li>\n<li>If the external agent works, investigate your internal agent registration or consider adopting the external agent + polling workaround.</li>\n<li>Be prepared to implement polling for critical property changes (<code class=\"language-text\">Paired</code>, <code class=\"language-text\">Trusted</code>, <code class=\"language-text\">Connected</code>, <code class=\"language-text\">ServicesResolved</code>) if D-Bus signals prove unreliable in your environment.</li>\n</ol>\n<p>While the final solution isn't as clean as initially envisioned, it provides a robust path forward for automated Bluetooth pairing in the face of these system-level complexities.</p>\n<hr>\n<h3>References</h3>\n<p><a id=\"ref1\"></a>1. <a href=\"https://github.com/bluez/bluez/issues/55\">BlueZ GitHub Issue: Device characteristics and pairing timing issues</a> - <em>Discussion about intermittent pairing failures that may be related to agent timing issues, similar to what we experienced.</em><br>\n<a id=\"ref2\"></a>2. <a href=\"https://forums.raspberrypi.com/viewtopic.php?t=324225\">Bluetooth Auto Pairing with NoInputNoOutput Agent Issues</a> - <em>Forum discussion about challenges with headless Bluetooth pairing using NoInputNoOutput agent capability.</em><br>\n<a id=\"ref3\"></a>3. <a href=\"https://git.kernel.org/pub/scm/bluetooth/bluez.git/tree/test/simple-agent\">BlueZ Source Code: test/simple-agent</a> - <em>The standard Python agent often used for testing.</em></p>\n<p><em>(Disclaimer: Specific online references detailing this exact sd-bus vs. python-dbus agent behavior with BlueZ 5.72+ might be scarce. The conclusions here are based primarily on the empirical evidence gathered during the debugging process described in our conversation.)</em></p>","frontmatter":{"title":"BlueZ Pairing Woes: Why We Switched to an External Python Agent (and Added Polling)","date":"April 08, 2025","description":"A developer's deep dive into troubleshooting BlueZ pairing issues on Linux, specifically the 'AuthenticationFailed' error with internal C++ agents, and the workarounds involving an external Python agent and D-Bus property polling.","imageCaption":"Navigating the complexities of BlueZ D-Bus pairing agent interactions on Linux.","tags":["BlueZ","DBus","PairingAgent","Python","C++","sd-bus","AuthenticationFailed","LinuxBluetooth","Workaround","BluetoothPairing","EmbeddedLinux"],"featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#080838","images":{"fallback":{"src":"https://bdteo.github.io/static/56a37a7145ca6dc6c4bdab99200fced4/83638/featured.jpg","srcSet":"https://bdteo.github.io/static/56a37a7145ca6dc6c4bdab99200fced4/7284f/featured.jpg 750w,\nhttps://bdteo.github.io/static/56a37a7145ca6dc6c4bdab99200fced4/29ba9/featured.jpg 1080w,\nhttps://bdteo.github.io/static/56a37a7145ca6dc6c4bdab99200fced4/c8896/featured.jpg 1366w,\nhttps://bdteo.github.io/static/56a37a7145ca6dc6c4bdab99200fced4/83638/featured.jpg 1536w","sizes":"100vw"},"sources":[{"srcSet":"https://bdteo.github.io/static/56a37a7145ca6dc6c4bdab99200fced4/57584/featured.webp 750w,\nhttps://bdteo.github.io/static/56a37a7145ca6dc6c4bdab99200fced4/984df/featured.webp 1080w,\nhttps://bdteo.github.io/static/56a37a7145ca6dc6c4bdab99200fced4/4a276/featured.webp 1366w,\nhttps://bdteo.github.io/static/56a37a7145ca6dc6c4bdab99200fced4/7db9c/featured.webp 1536w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.6666666666666666}}}}},"previous":{"fields":{"slug":"/understanding-class-namespace-changes-shopware-6-5-developers-guide/"},"frontmatter":{"title":"Understanding Class and Namespace Changes in Shopware 6.5 and 6.6: A Developer's Guide"}},"next":{"fields":{"slug":"/huawei-watch-d2-proprietary-protocol-vendor-lockin/"},"frontmatter":{"title":"Decoding Huawei's Handshake: A BLE Protocol Case Study in Vendor Lock-In"}}},"pageContext":{"id":"fa5ee807-c206-563f-ade2-c7ce58e4344f","previousPostId":"aebd6da9-0097-58e7-8ebb-b65a9f4e752f","nextPostId":"cd1ee447-b2fc-5d70-a6c6-53273acf7b66"}},"staticQueryHashes":["2923011943","3464938722"],"slicesMap":{}}