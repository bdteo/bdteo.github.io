{"componentChunkName":"component---src-templates-blog-post-js","path":"/huawei-watch-d2-proprietary-protocol-vendor-lockin/","result":{"data":{"site":{"siteMetadata":{"title":"Boris's Blog"}},"markdownRemark":{"id":"cd1ee447-b2fc-5d70-a6c6-53273acf7b66","excerpt":"Developing software to interact with hardware often leads you down unexpected paths. While working on D2Explorer, aiming to provide an open way to connect the…","html":"<p>Developing software to interact with hardware often leads you down unexpected paths. While working on D2Explorer, aiming to provide an open way to connect the Huawei Watch D2 to Linux and macOS systems, we encountered a Bluetooth pairing process far removed from the standard procedures we initially anticipated. After successfully migrating our Bluetooth communication layer from BlueZ/D-Bus to the cross-platform SimpleBLE library, the next hurdle wasn't the library itself, but the intricate, proprietary handshake demanded by the watch. This journey became a fascinating case study in how custom protocols can create significant barriers and effectively lock users into a vendor's ecosystem.</p>\n<h2>The Expectation: Standard Bluetooth LE Pairing</h2>\n<p>Going into this, particularly after adopting SimpleBLE, the expectation was relatively straightforward:</p>\n<ol>\n<li>Use SimpleBLE to scan for the watch based on its advertised name (e.g., \"HUAWEI WATCH D2-CA0\").</li>\n<li>Initiate a connection using <code class=\"language-text\">peripheral.connect()</code>.</li>\n<li>If pairing/bonding is required (e.g., to access protected characteristics), SimpleBLE would ideally trigger the <em>operating system's</em> standard pairing mechanism (like a PIN prompt or Just Works confirmation managed by macOS or BlueZ).</li>\n<li>Once connected and paired/bonded at the OS level, we'd interact with standard or custom GATT services to exchange data.</li>\n</ol>\n<p>This standard flow leverages the OS's Bluetooth stack for the core security and bonding, with the application focusing on GATT interactions.</p>\n<h2>The Reality: Huawei's Custom Application-Level Handshake</h2>\n<p>What we found, however, was entirely different. Establishing a basic BLE connection is merely the prelude. To actually <em>authenticate</em> the connection and gain access to meaningful data, the watch requires a complex, multi-step, application-level handshake orchestrated over custom GATT characteristics. Standard BLE pairing mechanisms seem insufficient or are bypassed entirely in favour of this proprietary flow.</p>\n<p>The process, painstakingly reverse-engineered and implemented in D2Explorer's <code class=\"language-text\">HuaweiPairingProtocol</code>, looks roughly like this:</p>\n<ol>\n<li><strong>Connect:</strong> Establish the basic BLE link.</li>\n<li><strong>Enable Notifications:</strong> <em>Immediately</em> subscribe to notifications on a specific custom characteristic (<code class=\"language-text\">0000fe02-...</code>). This is timing-critical.</li>\n<li><strong>GetLinkParams:</strong> <em>Immediately</em> send a custom command (Service ID <code class=\"language-text\">0x0001</code>, Command ID <code class=\"language-text\">0x0001</code>) to the write characteristic (<code class=\"language-text\">0000fe01-...</code>).</li>\n<li><strong>Receive Server Nonce:</strong> Wait for a notification containing the watch's nonce (random challenge).</li>\n<li><strong>Derive Secret Key:</strong> Generate a client nonce. Combine the server nonce, client nonce, and the <strong>numeric value from the watch's QR code</strong>. Use this combined data with HMAC-SHA256 (using the QR code value bytes as the key) to derive a shared <code class=\"language-text\">secretKey_</code>.</li>\n<li><strong>AuthRequest:</strong> Send the client nonce and an HMAC digest (using the derived <code class=\"language-text\">secretKey_</code>) back to the watch (Service <code class=\"language-text\">0x0001</code>, Command <code class=\"language-text\">0x0002</code>).</li>\n<li><strong>Verify Server Token:</strong> Receive a response containing the watch's authentication token. Verify this token using the derived <code class=\"language-text\">secretKey_</code> and exchanged nonces.</li>\n<li><strong>SetTime:</strong> Send the current phone/computer time and timezone offset to the watch, <em>encrypted</em> with the <code class=\"language-text\">secretKey_</code> (Service <code class=\"language-text\">0x0002</code>, Command <code class=\"language-text\">0x0003</code>).</li>\n<li><strong>QrToken:</strong> Send the original QR code value back to the watch, <em>encrypted</em> with the <code class=\"language-text\">secretKey_</code> (Service <code class=\"language-text\">0x0001</code>, Command <code class=\"language-text\">0x0004</code>).</li>\n<li><strong>AuthResult:</strong> Send a final confirmation message, <em>encrypted</em> with the <code class=\"language-text\">secretKey_</code> (Service <code class=\"language-text\">0x0001</code>, Command <code class=\"language-text\">0x0005</code>).</li>\n<li><strong>Authentication Complete:</strong> Only after successfully navigating all these steps is the connection considered authenticated by the watch.</li>\n</ol>\n<p>This involves custom TLV (Type-Length-Value) message formats, CRC checks, specific service/command IDs, application-level encryption, and, as we discovered, extremely sensitive timing requirements, especially between connection, notification enabling, and sending the first command.</p>\n<h2>Why So Complicated? Vendor Lock-In by Design</h2>\n<p>The natural question arises: Why abandon standard, well-documented Bluetooth pairing for such a convoluted custom process? While Huawei might cite enhanced security, the practical effect is overwhelmingly <strong>vendor lock-in</strong>.</p>\n<ul>\n<li><strong>High Barrier to Entry:</strong> This protocol is undocumented publicly. Reimplementing it requires significant reverse-engineering (analyzing official app traffic, firmware, or efforts like the Gadgetbridge project). This actively discourages third-party apps.</li>\n<li><strong>No Interoperability:</strong> Forget using standard fitness apps or data aggregators. The watch will only complete its handshake with software that knows these specific secret steps – primarily Huawei's own Health app.</li>\n<li><strong>Ecosystem Control:</strong> It forces users who want full functionality into the Huawei Health app and associated cloud services, making it harder to switch devices or platforms later.</li>\n<li><strong>Reduced User Choice:</strong> Users seeking open-source alternatives or more privacy-focused solutions are essentially blocked unless the community undertakes the significant effort to decode and replicate the protocol, which is the very purpose of D2Explorer.</li>\n</ul>\n<p>Bluetooth LE itself <em>allows</em> custom services, but this implementation goes far beyond defining custom data characteristics; it replaces the fundamental authentication mechanism with a proprietary gatekeeper.</p>\n<h2>The D2Explorer Effort: Rebuilding the Key</h2>\n<p>Our work on D2Explorer, therefore, shifted from simply using a BLE library to painstakingly reconstructing the client-side logic of this proprietary handshake. This involved:</p>\n<ul>\n<li>Implementing the specific TLV serialization/deserialization (<code class=\"language-text\">HuaweiProtocol</code>).</li>\n<li>Creating precise message builders (<code class=\"language-text\">ProtocolMessageBuilder</code>).</li>\n<li>Implementing the cryptographic steps (Nonce generation, HMAC-SHA256, XOR encryption) correctly (<code class=\"language-text\">CryptoOperations</code>, <code class=\"language-text\">CryptoUtils</code>).</li>\n<li>Managing the strict state transitions and timing (<code class=\"language-text\">HuaweiPairingProtocol</code>, <code class=\"language-text\">ProtocolStateManager</code>).</li>\n<li>Debugging failures often caused by millisecond-level timing mismatches or subtle crypto errors.</li>\n</ul>\n<p>The D2Explorer application exists <em>because</em> of this complexity; it's the \"workaround\" necessary to achieve basic functionality outside the vendor's walled garden.</p>\n<h2>Conclusion</h2>\n<p>The Huawei Watch D2's pairing mechanism is a prime example of how custom application-level protocols over standard transports like BLE can be used to enforce vendor lock-in. While standard BLE pairing has its own nuances, the additional layers of custom cryptography, message formats, and strict timing imposed by Huawei create a significant barrier designed, intentionally or not, to keep users within their ecosystem.</p>\n<p>Developing D2Explorer has been less about simply connecting Bluetooth devices and more about cryptographic detective work and precise protocol emulation. It underscores the value of open standards for interoperability and user choice in the connected device landscape. While we've managed to replicate the handshake, the effort involved highlights the hurdles placed in front of users and developers when companies prioritize proprietary control over open compatibility.</p>\n<hr>\n<h3>References</h3>\n<p><em>(Consider adding specific links or acknowledgements here if D2Explorer heavily relied on specific findings from other projects like Gadgetbridge)</em></p>\n<ul>\n<li><a href=\"https://gadgetbridge.org/\">Gadgetbridge Project</a> - <em>An open-source Android application often involved in reverse-engineering wearable protocols.</em> (Acknowledge if analysis was used)</li>\n<li><em>(Any other relevant technical blogs or findings used during development)</em></li>\n</ul>\n<p><em>(Disclaimer: The analysis of protocol steps and cryptographic methods is based on the implementation within D2Explorer and external community analysis. Official Huawei documentation is not publicly available.)</em></p>","frontmatter":{"title":"Decoding Huawei's Handshake: A BLE Protocol Case Study in Vendor Lock-In","date":"April 11, 2025","description":"Exploring the complex, non-standard Bluetooth LE pairing protocol of the Huawei Watch D2, the reverse-engineering required by D2Explorer, and how it exemplifies vendor lock-in strategies.","imageCaption":"Untangling the complex threads of a proprietary Bluetooth LE pairing protocol.","featuredImage":{"childImageSharp":{"gatsbyImageData":{"layout":"fullWidth","backgroundColor":"#080808","images":{"fallback":{"src":"https://bdteo.github.io/static/a273d3d9bb3291a37734d59b57d590c2/83638/featured.jpg","srcSet":"https://bdteo.github.io/static/a273d3d9bb3291a37734d59b57d590c2/7284f/featured.jpg 750w,\nhttps://bdteo.github.io/static/a273d3d9bb3291a37734d59b57d590c2/29ba9/featured.jpg 1080w,\nhttps://bdteo.github.io/static/a273d3d9bb3291a37734d59b57d590c2/c8896/featured.jpg 1366w,\nhttps://bdteo.github.io/static/a273d3d9bb3291a37734d59b57d590c2/83638/featured.jpg 1536w","sizes":"100vw"},"sources":[{"srcSet":"https://bdteo.github.io/static/a273d3d9bb3291a37734d59b57d590c2/57584/featured.webp 750w,\nhttps://bdteo.github.io/static/a273d3d9bb3291a37734d59b57d590c2/984df/featured.webp 1080w,\nhttps://bdteo.github.io/static/a273d3d9bb3291a37734d59b57d590c2/4a276/featured.webp 1366w,\nhttps://bdteo.github.io/static/a273d3d9bb3291a37734d59b57d590c2/7db9c/featured.webp 1536w","type":"image/webp","sizes":"100vw"}]},"width":1,"height":0.6666666666666666}}}}},"previous":{"fields":{"slug":"/bluez-pairing-python-agent-workaround-authentication-failed/"},"frontmatter":{"title":"BlueZ Pairing Woes: Why We Switched to an External Python Agent (and Added Polling)"}},"next":{"fields":{"slug":"/claude-code-transformed-my-blog-design-in-minutes/"},"frontmatter":{"title":"I Let Claude Code Redesign My Gatsby Blog and the Results Are Mind-Blowing"}}},"pageContext":{"id":"cd1ee447-b2fc-5d70-a6c6-53273acf7b66","previousPostId":"fa5ee807-c206-563f-ade2-c7ce58e4344f","nextPostId":"6d3ddfc4-21d4-5918-bb8d-fa04fa8fd4fa"}},"staticQueryHashes":["2841359383","2923011943"],"slicesMap":{}}